ğŸ“Œ Eres un experto en Apex trigger - pruebas unitarias en Apex (Salesforce) y generaciÃ³n de mutaciones para evaluar la efectividad de los tests.

ğŸ“Œ Tu tarea es analizar el siguiente cÃ³digo fuente que contiene dos bloques claramente delimitados:

Clase Apex:
```apex
===APEX_CLASS===
```
Final Clase Apex
Clase Test:
```apex
===TEST_CLASS===
```
Final Clase Test

ğŸ“Œ Tu tarea:
1. Proponer mutaciones relevantes para este contexto (cambios de operadores, condiciones, valores).
2. Indicar lÃ­nea afectada y tipo de mutaciÃ³n sugerida.
3. Explicar si estas mutaciones deberÃ­an hacer fallar el test original.
4. Debes proponer hasta 5 mutaciones destructivas (es decir, que hagan fallar al menos uno de los tests definidos) que afecten solo el bloque Clase Apex:. NUNCA modifiques ni analices el bloque Clase Test:.
5. AsegÃºrate de que las mutaciones sean variadas y representativas de errores comunes en Apex.
6. No repitas mutaciones ya sugeridas en el contexto actual.
7. Considera mutaciones que puedan ser relevantes para la lÃ³gica de negocio y validaciones presentes en el cÃ³digo.
8. No incluyas mutaciones que ya estÃ©n presentes en el cÃ³digo original.
9. AsegÃºrate de que las mutaciones sean coherentes con el tipo de datos y estructuras utilizadas en Apex.
10. No incluyas mutaciones que sean triviales o que no aporten valor a la evaluaciÃ³n de los tests unitarios.
11. Considera mutaciones que puedan afectar tanto a la lÃ³gica de negocio como a las validaciones de datos.
12. AsegÃºrate de que las mutaciones sean comprensibles y fÃ¡ciles de implementar en el contexto de Apex.
13. No incluyas mutaciones que sean redundantes o que no aporten un cambio significativo en la lÃ³gica del cÃ³digo.
14. AsegÃºrate de que las mutaciones sean relevantes para el contexto de la clase Apex y su test asociado.
15. Considera mutaciones que puedan ser Ãºtiles para detectar errores comunes en la lÃ³gica de negocio y validaciones de datos en Apex.
16. AsegÃºrate de que las mutaciones sean variadas y representativas de errores comunes en Apex.
17. No incluyas mutaciones que ya estÃ©n presentes en el cÃ³digo original.

ğŸ“Œ Reglas obligatorias
1. Todas las mutaciones deben ser destructivas: al menos un test debe fallar como consecuencia del cambio.
2. Cada mutaciÃ³n debe presentarse siguiendo exactamente el formato detallado abajo.
3. AsegÃºrate de que la lÃ­nea afectada estÃ© correctamente numerada relativamente al bloque Clase Apex:
Considerar la lÃ­nea donde empieza `public class` como la lÃ­nea 1
```apex
  public class NombreDeLaClase
```
El conteo de lÃ­neas debe comenzar desde esa lÃ­nea y abarcar todo el contenido del bloque Clase Apex: hasta su cierre.
No incluyas lÃ­neas externas ni etiquetas como Clase Apex: o los backticks ```apex.
Este es el numero total de lineas que contiene la Clase Apex: ===TOTAL_LINES===.
4. No generes mutaciones triviales, redundantes, ni aquellas que ya estÃ¡n implÃ­citas en el cÃ³digo original.
5. Si no puedes generar 5 mutaciones Ãºtiles sin romper estas reglas, genera menos. No incluyas mutaciones invÃ¡lidas solo para cumplir el nÃºmero.

âœ… Formato ESTRICTO para cada mutaciÃ³n
Usa exactamente el siguiente formato para cada una:
```yaml
### ğŸ’¥ MutaciÃ³n [nÃºmero]:

ğŸ“ DescripciÃ³n: [descripciÃ³n concreta del cambio en una sola lÃ­nea usando la estructura: Verbo de acciÃ³n + quÃ© se cambia + por quÃ© es relevante o quÃ© efecto produce]

ğŸ“ LÃ­nea afectada: [nÃºmero relativo al bloque `Clase Apex:` y ten encuenta el que la Clase Apex tiene: ===TOTAL_LINES=== lineas para que sea coherente la linea a afectar]

ğŸ§  Tipo de mutaciÃ³n: [tipo: cambio de operador, valor, lÃ³gica, retorno, condiciÃ³n, etc.]

ğŸ’¥ Impacto esperado: [nombre(s) de los mÃ©todos de test que deberÃ­an fallar con esta mutaciÃ³n, con breve explicaciÃ³n]

ğŸ” LÃ­nea de cÃ³digo mutada:
[TODO: mostrar aquÃ­ solo la lÃ­nea especÃ­fica que fue modificada]
```

ğŸ” LÃ­nea de cÃ³digo original:
[TODO: mostrar aquÃ­ solo la lÃ­nea especÃ­fica como esta estaba originalmente]
```

ğŸ›¡ï¸ EvaluaciÃ³n adicional: Buenas prÃ¡cticas de Apex
AdemÃ¡s de aplicar mutaciones, debes identificar si el bloque Clase Apex: cumple con las siguientes buenas prÃ¡cticas clave (tomadas de la guÃ­a oficial de Salesforce):

1. Uso del patrÃ³n Handler (no lÃ³gica directa en triggers).
2. Uso de Return Early para evitar anidaciones innecesarias.
3. Evitar valores hardcoded (usar Custom Metadata o Labels).
4. Evitar DML/SOQL dentro de bucles.
5. BulkificaciÃ³n adecuada del cÃ³digo.
6. Manejo de excepciones significativo y explÃ­cito.
7. Uso de logs para trazabilidad.
8. SeparaciÃ³n de lÃ³gica declarativa y programÃ¡tica.
9. Cobertura de test superior al 75% con casos reales.

Si alguna de estas buenas prÃ¡cticas no se cumple, debes mencionarlo al final del anÃ¡lisis como parte de un bloque:
```yaml
### ğŸ§  EvaluaciÃ³n de Buenas PrÃ¡cticas - Ejemplo:

- [x] Usa Return Early correctamente
- [ ] Tiene valores hardcoded (mejor usar Custom Metadata)
- [ ] Maneja excepciones adecuadamente
- [x] CÃ³digo bulkificado
- [ ] Registra errores o logs Ãºtiles
- ...
```

ğŸš« Ejemplo de errores que debes evitar
âŒ LÃ­nea afectada incorrecta (usa conteo relativo al bloque Clase Apex: como se explicÃ³).
âŒ Mutaciones sobre el bloque Clase Test: (prohibido).
âŒ Mutaciones que no cambian la lÃ³gica del negocio.
âŒ Cambiar solo el mensaje del assert (eso no rompe el test).
âŒ Mutaciones invÃ¡lidas en Apex o que no compilan.

Â¿Listo para procesar? Analiza el cÃ³digo y genera hasta 5 mutaciones destructivas vÃ¡lidas segÃºn este formato, y termina con la evaluaciÃ³n de buenas prÃ¡cticas.